
¡Excelente! Este es un paso fundamental para la experiencia de usuario y la validación de la entrada. Controlar el estado del botón "Añadir Anotación" dinámicamente es clave.
Para lograr esto, necesitamos:
1.	Estado Global para el Círculo: Mantener un seguimiento de si un círculo válido ha sido dibujado.
2.	Validación de Campos del Formulario: Comprobar si todos los campos de texto/textarea están rellenados.
3.	Función de Verificación y Activación/Desactivación: Una función que compruebe ambas condiciones y actualice el estado del botón.
4.	Event Listeners: Llamar a esta función de verificación cuando se dibuja un círculo y cuando cambian los campos del formulario.
5.	Reiniciar estado en "Reproducir": Al pulsar "Reproducir", debemos resetear el estado del círculo dibujado y, por lo tanto, deshabilitar el botón "Añadir Anotación".
Aquí está el código modificado con la lógica para el botón "Añadir Anotación":
Generated html
<!-- Contenedor principal que centrará todo el contenido de la herramienta -->
<div class="main-centered-container">
    <!-- Contenedor del selector de vídeo -->
    <div class="video-selector-card">
        <h1>Seleccione un vídeo:</h1>
        <div class="select-wrapper">
            <select id="videoSelect">
                <option value="" disabled selected>Cargando vídeos...</option>
            </select>
        </div>
    </div>

    <!-- Contenedor que agrupa el reproductor de vídeo y el formulario de marcado -->
    <div class="video-and-form-wrapper">
        <!-- Contenedor del reproductor de vídeo (inicialmente oculto) -->
        <div id="videoPlayerCard" class="video-player-card" style="display: none;">
            <!-- Contenedor para el vídeo y el canvas superpuesto -->
            <div class="video-canvas-wrapper">
                <video id="mainVideoPlayer" controls></video>
                <canvas id="markingCanvas" style="display: none;"></canvas> <!-- Canvas para dibujar -->
            </div>
            
            <p id="videoPlaceholder" class="video-placeholder">Seleccione un vídeo para comenzar</p>

            <!-- Contenedor para los botones personalizados -->
            <div class="custom-video-controls">
                <button id="playFromStartButton" class="custom-button primary-button">Reproducir</button>
                <button id="markButton" class="custom-button secondary-button">Marcar</button>
            </div>
        </div>

        <!-- Contenedor del formulario de marcado (inicialmente oculto) -->
        <div id="markingFormCard" class="marking-form-card" style="display: none;">
            <h2>Añadir marca</h2>

            <!-- Selector de color -->
            <div class="form-group">
                <label for="colorSelect">Color</label>
                <div class="select-wrapper">
                    <select id="colorSelect">
                        <option value="red">🔴 Rojo</option>
                        <option value="green">🟢 Verde</option>
                        <option value="blue" selected>🔵 Azul</option>
                        <option value="yellow">🟡 Amarillo</option>
                        <option value="purple">🟣 Morado</option>
                        <option value="orange">🟠 Naranja</option>
                    </select>
                </div>
            </div>

            <!-- Aquí se generarán los campos del formulario dinámicamente -->
            <div id="dynamicFormFields"></div>

            <button id="addAnnotationButton" class="custom-button annotation-button" disabled>Añadir Anotación</button>
        </div>
    </div>
</div>


<script>
document.addEventListener('DOMContentLoaded', function() {
    // === CONFIGURACIÓN IMPORTANTE ===
    const MOODLE_CONTEXT_ID = '605943'; // <<-- ¡MODIFICA ESTO CON EL ID CORRECTO DE TU CARPETA!
    const FOLDER_PATH = 'Bloque%201/';
    const MOODLE_BASE_URL = window.location.origin;
    const FILES_BASE_URL = MOODLE_BASE_URL + `/pluginfile.php/${MOODLE_CONTEXT_ID}/mod_folder/content/0/${FOLDER_PATH}`;
    const JSON_FILENAME_TO_LOAD = 'data.json';
    const CIRCLE_RADIUS = 40; // Radio fijo del círculo en píxeles

    const videoSelect = document.getElementById('videoSelect');
    const videoPlayerCard = document.getElementById('videoPlayerCard');
    const mainVideoPlayer = document.getElementById('mainVideoPlayer');
    const videoPlaceholder = document.getElementById('videoPlaceholder');
    const playFromStartButton = document.getElementById('playFromStartButton');
    const markButton = document.getElementById('markButton');
    const markingFormCard = document.getElementById('markingFormCard');
    const dynamicFormFields = document.getElementById('dynamicFormFields');
    const addAnnotationButton = document.getElementById('addAnnotationButton');
    const markingCanvas = document.getElementById('markingCanvas');
    const colorSelect = document.getElementById('colorSelect');

    let formFieldsDefinition = [];
    let canvasContext = markingCanvas.getContext('2d');
    let circleDrawn = false; // Nuevo: Bandera para saber si se ha dibujado un círculo

    async function loadData(jsonFilename) {
        videoSelect.innerHTML = '<option value="" disabled selected>Cargando vídeos...</option>';
        try {
            const response = await fetch(FILES_BASE_URL + jsonFilename);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();

            videoSelect.innerHTML = '<option value="" disabled selected>Seleccione un vídeo</option>';
            data.videos.forEach(video => {
                const option = document.createElement('option');
                option.value = FILES_BASE_URL + video.url + '?forcedownload=1';
                option.textContent = video.nombre;
                videoSelect.appendChild(option);
            });
            formFieldsDefinition = data.camposFormulario && Array.isArray(data.camposFormulario) ? data.camposFormulario : [];
        } catch (error) {
            console.error('Error al cargar los datos:', error);
            videoSelect.innerHTML = '<option value="" disabled selected>Error al cargar vídeos</option>';
            alert('No se pudieron cargar los datos. Por favor, verifique la configuración o la disponibilidad de los archivos.');
        }
    }

    function generateFormFields() {
        dynamicFormFields.innerHTML = '';
        formFieldsDefinition.forEach((field, index) => {
            const formGroup = document.createElement('div');
            formGroup.classList.add('form-group');

            const label = document.createElement('label');
            label.textContent = field.etiqueta;
            label.setAttribute('for', `field-${index}`);

            let inputElement;
            if (field.tipo === 'textarea') {
                inputElement = document.createElement('textarea');
                inputElement.placeholder = 'Breve descripción...';
                inputElement.rows = 4;
            } else {
                inputElement = document.createElement('input');
                inputElement.type = 'text';
                inputElement.placeholder = field.etiqueta.replace(':', '').trim();
            }
            inputElement.id = `field-${index}`;
            inputElement.classList.add('form-input');
            inputElement.addEventListener('input', checkButtonState); // Nuevo: Añadir listener para la validación

            formGroup.appendChild(label);
            formGroup.appendChild(inputElement);
            dynamicFormFields.appendChild(formGroup);
        });
        checkButtonState(); // Nuevo: Verificar estado inicial del botón al generar campos
    }

    // Función para dibujar un círculo en el canvas
    function drawCircle(x, y, radius, color) {
        canvasContext.clearRect(0, 0, markingCanvas.width, markingCanvas.height); // Limpiar canvas
        canvasContext.beginPath();
        canvasContext.arc(x, y, radius, 0, Math.PI * 2, false);
        canvasContext.strokeStyle = color;
        canvasContext.lineWidth = 3; // Ancho del borde del círculo
        canvasContext.stroke();
        circleDrawn = true; // Nuevo: Establecer bandera a true
        checkButtonState(); // Nuevo: Verificar estado del botón
    }

    // Función para manejar el clic en el canvas para dibujar
    function handleCanvasClick(event) {
        const rect = markingCanvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const selectedColor = colorSelect.value;
        
        drawCircle(x, y, CIRCLE_RADIUS, selectedColor);
        // No almacenamos 'currentCircle' como objeto separado si solo necesitamos saber si está dibujado
        // Si más adelante necesitamos persistir la posición para redibujar al cambiar tamaño, sí sería útil.
    }

    // Nuevo: Función para verificar si todos los campos del formulario están llenos
    function areFormFieldsFilled() {
        const inputElements = dynamicFormFields.querySelectorAll('.form-input');
        for (let i = 0; i < inputElements.length; i++) {
            if (inputElements[i].value.trim() === '') {
                return false;
            }
        }
        return true;
    }

    // Nuevo: Función para verificar y actualizar el estado del botón "Añadir Anotación"
    function checkButtonState() {
        const allConditionsMet = circleDrawn && areFormFieldsFilled();
        addAnnotationButton.disabled = !allConditionsMet;
        // Opcional: para cambiar la apariencia visual directamente si 'disabled' no es suficiente
        if (allConditionsMet) {
            addAnnotationButton.classList.remove('disabled-button');
        } else {
            addAnnotationButton.classList.add('disabled-button');
        }
    }


    function handleVideoSelection() {
        const selectedVideoUrl = videoSelect.value;
        if (selectedVideoUrl) {
            mainVideoPlayer.src = selectedVideoUrl;
            mainVideoPlayer.load();
            videoPlayerCard.style.display = 'flex';
            videoPlayerCard.classList.remove('shrink-player');
            markingFormCard.style.display = 'none';
            videoPlaceholder.style.display = 'none';
            markingFormCard.style.minHeight = 'auto';
            
            markingCanvas.style.display = 'none';
            markingCanvas.removeEventListener('click', handleCanvasClick);
            canvasContext.clearRect(0, 0, markingCanvas.width, markingCanvas.height);
            circleDrawn = false; // Nuevo: Resetear estado del círculo
            checkButtonState(); // Nuevo: Verificar estado del botón
        } else {
            mainVideoPlayer.pause();
            mainVideoPlayer.src = "";
            videoPlayerCard.style.display = 'none';
            markingFormCard.style.display = 'none';
            markingFormCard.style.minHeight = 'auto';

            markingCanvas.style.display = 'none';
            markingCanvas.removeEventListener('click', handleCanvasClick);
            canvasContext.clearRect(0, 0, markingCanvas.width, markingCanvas.height);
            circleDrawn = false; // Nuevo: Resetear estado del círculo
            checkButtonState(); // Nuevo: Verificar estado del botón
        }
    }

    function adjustFormHeight() {
        requestAnimationFrame(() => {
            const playerHeight = videoPlayerCard.offsetHeight;
            if (playerHeight > 0) {
                markingFormCard.style.minHeight = `${playerHeight}px`;
                markingCanvas.width = mainVideoPlayer.offsetWidth;
                markingCanvas.height = mainVideoPlayer.offsetHeight;
                // Si el círculo estaba dibujado, redibujarlo para que se ajuste a las nuevas dimensiones
                if (circleDrawn) { // Si solo necesitamos saber si está dibujado, la bandera es suficiente
                    // Si queremos que el círculo se "estire" con el video, necesitamos almacenar sus coordenadas.
                    // Para este requisito, solo necesitamos redibujarlo si estaba presente.
                    // Para que se reescale correctamente al redibujar, necesitaríamos almacenar x,y relativas (porcentaje)
                    // Para simplificar, asumimos que al redimensionar, se limpia y se redibuja en una nueva posición.
                    // Si se desea persistir, `currentCircle` como objeto es necesario.
                    // Por ahora, solo limpiaremos si el video se redimensiona drásticamente.
                    canvasContext.clearRect(0, 0, markingCanvas.width, markingCanvas.height);
                    circleDrawn = false; // Forzar al usuario a redibujar si el canvas cambió de tamaño
                    checkButtonState(); // Deshabilitar el botón si el círculo se "pierde"
                }
            }
        });
    }

    markButton.addEventListener('click', function() {
        if (mainVideoPlayer.src) {
            mainVideoPlayer.pause();
            generateFormFields(); // Esto llama a checkButtonState() internamente

            videoPlayerCard.classList.add('shrink-player');
            markingFormCard.style.display = 'flex';

            markingCanvas.style.display = 'block';
            markingCanvas.width = mainVideoPlayer.offsetWidth;
            markingCanvas.height = mainVideoPlayer.offsetHeight;
            
            // Limpiar canvas y resetear estado del círculo al entrar en modo marcado
            canvasContext.clearRect(0, 0, markingCanvas.width, markingCanvas.height);
            circleDrawn = false; 
            checkButtonState(); // Asegurar que el botón esté deshabilitado al entrar en modo marcado

            markingCanvas.addEventListener('click', handleCanvasClick);

            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    if (entry.target === videoPlayerCard) {
                        adjustFormHeight();
                        if (Math.abs(entry.contentRect.height - videoPlayerCard.offsetHeight) < 1) {
                             resizeObserver.disconnect();
                        }
                    }
                }
            });
            resizeObserver.observe(videoPlayerCard);
            adjustFormHeight();
        }
    });

    playFromStartButton.addEventListener('click', function() {
        if (mainVideoPlayer.src) {
            mainVideoPlayer.currentTime = 0;
            mainVideoPlayer.play();
            videoPlayerCard.classList.remove('shrink-player');
            markingFormCard.style.display = 'none';
            markingFormCard.style.minHeight = 'auto';

            markingCanvas.style.display = 'none';
            markingCanvas.removeEventListener('click', handleCanvasClick);
            canvasContext.clearRect(0, 0, markingCanvas.width, markingCanvas.height);
            circleDrawn = false; // Nuevo: Resetear estado del círculo
            checkButtonState(); // Nuevo: Verificar estado del botón
        }
    });

    videoSelect.addEventListener('change', handleVideoSelection);
    addAnnotationButton.addEventListener('click', function() {
        // Esta función solo se ejecutará si el botón está habilitado
        alert('Botón "Añadir Anotación" clicado. Ambas condiciones cumplidas.');
        // Aquí iría la lógica para guardar la anotación
    });

    loadData(JSON_FILENAME_TO_LOAD);

    // --- Inyección de estilos CSS ---
    const style = document.createElement('style');
    style.textContent = `
        /* Contenedor principal que centra todo el contenido de la herramienta */
        .main-centered-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 50px;
            width: 100%;
            box-sizing: border-box;
        }

        /* Contenedor del selector de vídeo (primera tarjeta) */
        .video-selector-card {
            text-align: center;
            padding: 20px;
            background-color: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            max-width: 400px;
            width: 90%;
            margin-bottom: 30px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            box-sizing: border-box;
        }

        .video-selector-card h1 {
            font-size: 1.4em;
            color: #333;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .select-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        #videoSelect, #colorSelect {
            width: 100%;
            padding: 12px 15px;
            font-size: 1em;
            border: 1px solid #dcdcdc;
            border-radius: 6px;
            background-color: #ffffff;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            cursor: pointer;
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            color: #555;
        }

        #videoSelect:focus, #colorSelect:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
        }

        .select-wrapper::after {
            content: '⌄';
            font-size: 1.2em;
            color: #888;
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
        }

        /* Contenedor que alinea horizontalmente el reproductor y el formulario */
        .video-and-form-wrapper {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start;
            width: 100%;
            max-width: 1200px;
            gap: 30px;
            flex-wrap: wrap;
        }

        /* Contenedor del reproductor de vídeo */
        .video-player-card {
            width: 90%;
            max-width: 700px;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            color: #fff;
            padding: 5px;
            border: 1px solid #e0e0e0;
            box-sizing: border-box;
            transition: max-width 0.3s ease-in-out;
        }

        /* Clase para reducir el tamaño del reproductor cuando el formulario está visible */
        .video-player-card.shrink-player {
            max-width: 450px;
        }

        /* Wrapper para el video y el canvas superpuesto */
        .video-canvas-wrapper {
            position: relative;
            width: 100%;
            height: auto;
            flex-grow: 1;
            display: flex; /* Para centrar el video dentro del wrapper si no lo llena */
            justify-content: center;
            align-items: center;
            /* No padding-bottom aquí, los controles del video y los botones están fuera de esta área */
        }

        /* Estilos para el elemento <video> */
        #mainVideoPlayer {
            width: 100%;
            height: 100%; /* El vídeo llenará el wrapper */
            min-height: 250px;
            display: block;
            border-radius: 6px;
            object-fit: contain;
            background-color: black;
        }

        /* Estilos para el Canvas de marcado */
        #markingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            z-index: 10; /* Asegura que el canvas esté sobre el vídeo */
        }


        /* Estilos para el mensaje de placeholder */
        .video-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ccc;
            font-size: 1.1em;
            text-align: center;
            padding: 15px;
        }

        /* Contenedor de los botones personalizados debajo del vídeo */
        .custom-video-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            width: 100%;
            padding: 10px 0;
            flex-shrink: 0;
            margin-top: auto;
        }

        /* Estilos para los botones personalizados (general) */
        .custom-button {
            border: none;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, opacity 0.2s ease; /* Añadir opacidad a la transición */
            flex-grow: 1;
            max-width: 150px;
            box-sizing: border-box;
            white-space: nowrap;
            padding: 10px 20px;
        }

        /* Estilos para el botón principal (Reproducir) */
        .custom-button.primary-button {
            background-color: #007bff;
            color: white;
        }
        .custom-button.primary-button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        .custom-button.primary-button:active {
            background-color: #004085;
            transform: translateY(0);
        }

        /* Estilos para el botón secundario (Marcar) */
        .custom-button.secondary-button {
            background-color: #f0f0f0;
            color: #333;
            border: 1px solid #dcdcdc;
        }
        .custom-button.secondary-button:hover {
            background-color: #e0e0e0;
            transform: translateY(-2px);
        }
        .custom-button.secondary-button:active {
            background-color: #d0d0d0;
            transform: translateY(0);
        }

        /* Contenedor del formulario de marcado */
        .marking-form-card {
            background-color: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            width: 90%;
            max-width: 450px;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            align-self: flex-start;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .marking-form-card h2 {
            font-size: 1.2em;
            color: #333;
            margin-bottom: 20px;
            font-weight: 500;
            text-align: left;
        }

        .form-group {
            margin-bottom: 15px;
            text-align: left;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #444;
            font-size: 0.95em;
        }

        .form-input {
            width: calc(100% - 20px);
            padding: 10px;
            border: 1px solid #dcdcdc;
            border-radius: 6px;
            font-size: 1em;
            color: #555;
            background-color: #ffffff;
            box-sizing: border-box;
        }

        .form-input:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
            outline: none;
        }

        /* Estilos específicos para el selector de color */
        #colorSelect {
            padding-left: 40px;
        }

        /* Estilos para el botón "Añadir Anotación" */
        .custom-button.annotation-button {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            white-space: nowrap;
            flex-grow: 0;
            align-self: center;
            margin-top: auto;
            max-width: 250px;
        }
        .custom-button.annotation-button:hover:not(:disabled) { /* Solo hover si no está deshabilitado */
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        .custom-button.annotation-button:active:not(:disabled) { /* Solo active si no está deshabilitado */
            background-color: #004085;
            transform: translateY(0);
        }

        /* Estilo para los botones deshabilitados */
        .custom-button[disabled], .custom-button.disabled-button {
            opacity: 0.6;
            cursor: not-allowed;
            pointer-events: none; /* Asegura que no responda a clicks */
            box-shadow: none;
            transform: none;
        }


        /* Ajustes para pantallas más pequeñas (flex-wrap) */
        @media (max-width: 1100px) {
            .video-and-form-wrapper {
                flex-direction: column;
                align-items: center;
            }

            .video-player-card, .marking-form-card {
                max-width: 700px;
                width: 90%;
                min-height: auto;
            }

            .video-player-card.shrink-player {
                max-width: 700px;
            }

            .marking-form-card {
                margin-top: 30px;
            }
        }
    `;
    document.head.appendChild(style);
});
</script>
content_copydownload
Use code with caution.Html
Novedades y cambios para la validación y el estado del botón "Añadir Anotación":
1.	HTML del botón:
o	Le hemos añadido el atributo disabled por defecto en el HTML:
<button id="addAnnotationButton" class="custom-button annotation-button" disabled>Añadir Anotación</button>
Esto asegura que el botón esté deshabilitado desde el primer momento que la página se carga.
2.	Estado del Círculo (circleDrawn):
o	Se ha introducido una nueva variable booleana let circleDrawn = false; en el ámbito global del script para mantener el seguimiento de si un círculo válido ha sido dibujado en el canvas.
o	drawCircle(): Se establece circleDrawn = true; y se llama a checkButtonState().
o	handleVideoSelection() y playFromStartButton.addEventListener('click', ...): Se restablece circleDrawn = false; y se llama a checkButtonState() para deshabilitar el botón si el vídeo se reinicia o se cambia.
o	markButton.addEventListener('click', ...): Al entrar en el modo de marcado, el canvas se limpia y circleDrawn = false; para forzar al usuario a dibujar un nuevo círculo.
3.	Validación de Campos (areFormFieldsFilled()):
o	Una nueva función areFormFieldsFilled() itera sobre todos los elementos con la clase form-input dentro de dynamicFormFields y devuelve true solo si todos tienen un valor no vacío (.value.trim() !== '').
4.	Función checkButtonState() (El Corazón de la Lógica):
o	Esta nueva función es la que decide el estado final del botón "Añadir Anotación".
o	const allConditionsMet = circleDrawn && areFormFieldsFilled();: Comprueba si el círculo está dibujado Y todos los campos están llenos.
o	addAnnotationButton.disabled = !allConditionsMet;: Habilita (false) o deshabilita (true) el botón en función de allConditionsMet.
o	addAnnotationButton.classList.add/remove('disabled-button');: Se añade/quita una clase CSS adicional para controlar la apariencia visual (opacidad reducida, cursor not-allowed).
5.	Event Listeners para Disparar la Verificación:
o	En la generación de campos (generateFormFields()): Cada campo de formulario (inputElement) ahora tiene un addEventListener('input', checkButtonState);. Esto significa que cada vez que el usuario escribe algo en un campo de texto, se verifica el estado del botón.
o	generateFormFields() también llama a checkButtonState() al final, para asegurar que el botón esté en el estado correcto inmediatamente después de que los campos se generan.
o	En drawCircle(): Después de dibujar un círculo, se llama a checkButtonState().
6.	Ajustes CSS para disabled:
o	Se ha añadido un estilo específico para los botones [disabled] y la nueva clase .disabled-button.
o	opacity: 0.6; cursor: not-allowed; pointer-events: none;: Estas propiedades aseguran que el botón se vea atenuado, el cursor cambie y, lo más importante, que no responda a clics (el pointer-events: none es crucial para esto).
o	También se han ajustado los :hover y :active de annotation-button para que not(:disabled) solo aplique los efectos de transición si el botón NO está deshabilitado.
Ahora, cuando pruebes la herramienta:
•	Al cargar la página, el botón "Añadir Anotación" estará deshabilitado.
•	Al hacer clic en "Marcar", el formulario aparece, pero el botón sigue deshabilitado (ya que aún no has dibujado un círculo y/o llenado los campos).
•	Si empiezas a rellenar los campos pero no haces clic en el vídeo, el botón seguirá deshabilitado.
•	Si haces clic en el vídeo para dibujar un círculo pero dejas campos vacíos, el botón seguirá deshabilitado.
•	Solo cuando ambas condiciones se cumplen, el botón se habilitará y cambiará su apariencia.
•	Al pulsar "Reproducir" (desde el estado de marcado), se reiniciará el estado de marcado, el círculo desaparecerá y el botón "Añadir Anotación" se deshabilitará de nuevo, listo para un nuevo ciclo de marcado.
